{"version":3,"file":"BLvrINZ5.js","sources":["../../../../node_modules/@nuxtjs/mdc/dist/runtime/components/MDCRenderer.vue"],"sourcesContent":["<script>\nimport { h, resolveComponent, reactive, watch, Text, Comment, defineAsyncComponent, defineComponent, toRaw, computed, getCurrentInstance } from \"vue\";\nimport destr from \"destr\";\nimport { kebabCase, pascalCase } from \"scule\";\nimport { find, html } from \"property-information\";\nimport htmlTags from \"../parser/utils/html-tags-list\";\nimport { flatUnwrap } from \"../utils/node\";\nconst DEFAULT_SLOT = \"default\";\nconst rxOn = /^@|^v-on:/;\nconst rxBind = /^:|^v-bind:/;\nconst rxModel = /^v-model/;\nconst nativeInputs = [\"select\", \"textarea\", \"input\"];\nconst proseComponentMap = Object.fromEntries([\"p\", \"a\", \"blockquote\", \"code\", \"pre\", \"code\", \"em\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"hr\", \"img\", \"ul\", \"ol\", \"li\", \"strong\", \"table\", \"thead\", \"tbody\", \"td\", \"th\", \"tr\", \"script\"].map((t) => [t, `prose-${t}`]));\nexport default defineComponent({\n  name: \"MDCRenderer\",\n  props: {\n    /**\n     * Content to render\n     */\n    body: {\n      type: Object,\n      required: true\n    },\n    /**\n     * Document meta data\n     */\n    data: {\n      type: Object,\n      default: () => ({})\n    },\n    /**\n     * Class(es) to bind to the component\n     */\n    class: {\n      type: [String, Object],\n      default: void 0\n    },\n    /**\n     * Root tag to use for rendering\n     */\n    tag: {\n      type: [String, Boolean],\n      default: void 0\n    },\n    /**\n     * Whether or not to render Prose components instead of HTML tags\n     */\n    prose: {\n      type: Boolean,\n      default: void 0\n    },\n    /**\n     * The map of custom components to use for rendering.\n     */\n    components: {\n      type: Object,\n      default: () => ({})\n    },\n    /**\n     * Tags to unwrap separated by spaces\n     * Example: 'ul li'\n     */\n    unwrap: {\n      type: [Boolean, String],\n      default: false\n    }\n  },\n  async setup(props) {\n    const $nuxt = getCurrentInstance()?.appContext?.app?.$nuxt;\n    const route = $nuxt?.$route || $nuxt?._route;\n    const { mdc } = $nuxt?.$config?.public || {};\n    const tags = {\n      ...mdc?.components?.prose && props.prose !== false ? proseComponentMap : {},\n      ...mdc?.components?.map || {},\n      ...toRaw(props.data?.mdc?.components || {}),\n      ...props.components\n    };\n    const contentKey = computed(() => {\n      const components = (props.body?.children || []).map((n) => n.tag || n.type).filter((t) => !htmlTags.includes(t));\n      return Array.from(new Set(components)).sort().join(\".\");\n    });\n    const runtimeData = reactive({\n      ...props.data\n    });\n    watch(() => props.data, (newData) => {\n      Object.assign(runtimeData, newData);\n    });\n    await resolveContentComponents(props.body, { tags });\n    function updateRuntimeData(code, value) {\n      const lastIndex = code.split(\".\").length - 1;\n      return code.split(\".\").reduce((o, k, i) => {\n        if (i == lastIndex && o) {\n          o[k] = value;\n          return o[k];\n        }\n        return typeof o === \"object\" ? o[k] : void 0;\n      }, runtimeData);\n    }\n    return { tags, contentKey, route, runtimeData, updateRuntimeData };\n  },\n  render(ctx) {\n    const { tags, tag, body, data, contentKey, route, unwrap, runtimeData, updateRuntimeData } = ctx;\n    if (!body) {\n      return null;\n    }\n    const meta = { ...data, tags, $route: route, runtimeData, updateRuntimeData };\n    const component = tag !== false ? resolveVueComponent(tag || meta.component?.name || meta.component || \"div\") : void 0;\n    return component ? h(component, { ...meta.component?.props, class: ctx.class, ...this.$attrs, key: contentKey }, { default: defaultSlotRenderer }) : defaultSlotRenderer?.();\n    function defaultSlotRenderer() {\n      if (unwrap) {\n        return flatUnwrap(\n          renderSlots(body, h, meta, meta).default(),\n          typeof unwrap === \"string\" ? unwrap.split(\" \") : [\"*\"]\n        );\n      }\n      return renderSlots(body, h, meta, meta).default();\n    }\n  }\n});\nfunction renderNode(node, h2, documentMeta, parentScope = {}) {\n  if (node.type === \"text\") {\n    return h2(Text, node.value);\n  }\n  if (node.type === \"comment\") {\n    return h2(Comment, null, node.value);\n  }\n  const originalTag = node.tag;\n  const renderTag = findMappedTag(node, documentMeta.tags);\n  if (node.tag === \"binding\") {\n    return renderBinding(node, h2, documentMeta, parentScope);\n  }\n  const component = resolveVueComponent(renderTag);\n  if (typeof component === \"object\") {\n    component.tag = originalTag;\n  }\n  const props = propsToData(node, documentMeta);\n  return h2(\n    component,\n    props,\n    renderSlots(node, h2, documentMeta, { ...parentScope, ...props })\n  );\n}\nfunction renderBinding(node, h2, documentMeta, parentScope = {}) {\n  const data = {\n    ...documentMeta.runtimeData,\n    ...parentScope,\n    $document: documentMeta,\n    $doc: documentMeta\n  };\n  const splitter = /\\.|\\[(\\d+)\\]/;\n  const keys = node.props?.value.trim().split(splitter).filter(Boolean);\n  const value = keys.reduce((data2, key) => {\n    if (data2 && key in data2) {\n      if (typeof data2[key] === \"function\") {\n        return data2[key]();\n      } else {\n        return data2[key];\n      }\n    }\n    return void 0;\n  }, data);\n  const defaultValue = node.props?.defaultValue;\n  return h2(Text, value ?? defaultValue ?? \"\");\n}\nfunction renderSlots(node, h2, documentMeta, parentProps) {\n  const children = node.children || [];\n  const slotNodes = children.reduce((data, node2) => {\n    if (!isTemplate(node2)) {\n      data[DEFAULT_SLOT].push(node2);\n      return data;\n    }\n    const slotName = getSlotName(node2);\n    data[slotName] = data[slotName] || [];\n    if (node2.type === \"element\") {\n      data[slotName].push(...node2.children || []);\n    }\n    return data;\n  }, {\n    [DEFAULT_SLOT]: []\n  });\n  const slots = Object.entries(slotNodes).reduce((slots2, [name, children2]) => {\n    if (!children2.length) {\n      return slots2;\n    }\n    slots2[name] = () => {\n      const vNodes = children2.map((child) => renderNode(child, h2, documentMeta, parentProps));\n      return mergeTextNodes(vNodes);\n    };\n    return slots2;\n  }, {});\n  return slots;\n}\nfunction propsToData(node, documentMeta) {\n  const { tag = \"\", props = {} } = node;\n  return Object.keys(props).reduce(function(data, key) {\n    if (key === \"__ignoreMap\") {\n      return data;\n    }\n    const value = props[key];\n    if (rxModel.test(key)) {\n      return propsToDataRxModel(key, value, data, documentMeta, { native: nativeInputs.includes(tag) });\n    }\n    if (key === \"v-bind\") {\n      return propsToDataVBind(key, value, data, documentMeta);\n    }\n    if (rxOn.test(key)) {\n      return propsToDataRxOn(key, value, data, documentMeta);\n    }\n    if (rxBind.test(key)) {\n      return propsToDataRxBind(key, value, data, documentMeta);\n    }\n    const { attribute } = find(html, key);\n    if (Array.isArray(value) && value.every((v) => typeof v === \"string\")) {\n      data[attribute] = value.join(\" \");\n      return data;\n    }\n    data[attribute] = value;\n    return data;\n  }, {});\n}\nfunction propsToDataRxModel(key, value, data, documentMeta, { native }) {\n  const propName = key.match(/^v-model:([^=]+)/)?.[1] || \"modelValue\";\n  const field = native ? \"value\" : propName;\n  const event = native ? \"onInput\" : `onUpdate:${propName}`;\n  data[field] = evalInContext(value, documentMeta.runtimeData);\n  data[event] = (e) => {\n    documentMeta.updateRuntimeData(value, native ? e.target?.value : e);\n  };\n  return data;\n}\nfunction propsToDataVBind(_key, value, data, documentMeta) {\n  const val = evalInContext(value, documentMeta);\n  data = Object.assign(data, val);\n  return data;\n}\nfunction propsToDataRxOn(key, value, data, documentMeta) {\n  key = key.replace(rxOn, \"\");\n  data.on = data.on || {};\n  data.on[key] = () => evalInContext(value, documentMeta);\n  return data;\n}\nfunction propsToDataRxBind(key, value, data, documentMeta) {\n  key = key.replace(rxBind, \"\");\n  data[key] = evalInContext(value, documentMeta);\n  return data;\n}\nconst resolveVueComponent = (component) => {\n  if (typeof component === \"string\") {\n    if (htmlTags.includes(component)) {\n      return component;\n    }\n    const _component = resolveComponent(pascalCase(component), false);\n    if (!component || _component?.name === \"AsyncComponentWrapper\") {\n      return _component;\n    }\n    if (typeof _component === \"string\") {\n      return _component;\n    }\n    if (\"setup\" in _component) {\n      return defineAsyncComponent(() => new Promise((resolve) => resolve(_component)));\n    }\n    return _component;\n  }\n  return component;\n};\nfunction evalInContext(code, context) {\n  const result = code.split(\".\").reduce((o, k) => typeof o === \"object\" ? o[k] : void 0, context);\n  return typeof result === \"undefined\" ? destr(code) : result;\n}\nfunction getSlotName(node) {\n  let name = \"\";\n  for (const propName of Object.keys(node.props || {})) {\n    if (!propName.startsWith(\"#\") && !propName.startsWith(\"v-slot:\")) {\n      continue;\n    }\n    name = propName.split(/[:#]/, 2)[1];\n    break;\n  }\n  return name || DEFAULT_SLOT;\n}\nfunction isTemplate(node) {\n  return node.tag === \"template\";\n}\nfunction mergeTextNodes(nodes) {\n  const mergedNodes = [];\n  for (const node of nodes) {\n    const previousNode = mergedNodes[mergedNodes.length - 1];\n    if (node.type === Text && previousNode?.type === Text) {\n      previousNode.children = previousNode.children + node.children;\n    } else {\n      mergedNodes.push(node);\n    }\n  }\n  return mergedNodes;\n}\nasync function resolveContentComponents(body, meta) {\n  if (!body) {\n    return;\n  }\n  const components = Array.from(new Set(loadComponents(body, meta)));\n  await Promise.all(components.map(async (c) => {\n    if (c?.render || c?.ssrRender || c?.__ssrInlineRender) {\n      return;\n    }\n    const resolvedComponent = resolveVueComponent(c);\n    if (resolvedComponent?.__asyncLoader && !resolvedComponent.__asyncResolved) {\n      await resolvedComponent.__asyncLoader();\n    }\n  }));\n  function loadComponents(node, documentMeta) {\n    const tag = node.tag;\n    if (node.type === \"text\" || tag === \"binding\" || node.type === \"comment\") {\n      return [];\n    }\n    const renderTag = findMappedTag(node, documentMeta.tags);\n    const components2 = [];\n    if (node.type !== \"root\" && !htmlTags.includes(renderTag)) {\n      components2.push(renderTag);\n    }\n    for (const child of node.children || []) {\n      components2.push(...loadComponents(child, documentMeta));\n    }\n    return components2;\n  }\n}\nfunction findMappedTag(node, tags) {\n  const tag = node.tag;\n  if (!tag || typeof node.props?.__ignoreMap !== \"undefined\") {\n    return tag;\n  }\n  return tags[tag] || tags[pascalCase(tag)] || tags[kebabCase(node.tag)] || tag;\n}\n</script>\n"],"names":["DEFAULT_SLOT","rxOn","rxBind","rxModel","nativeInputs","proseComponentMap","t","_sfc_main","defineComponent","props","$nuxt","_c","_b","_a","getCurrentInstance","route","mdc","_d","tags","_e","_f","toRaw","_h","_g","contentKey","computed","components","n","htmlTags","runtimeData","reactive","watch","newData","resolveContentComponents","updateRuntimeData","code","value","lastIndex","o","k","i","ctx","tag","body","data","unwrap","meta","component","resolveVueComponent","h","defaultSlotRenderer","flatUnwrap","renderSlots","renderNode","node","h2","documentMeta","parentScope","Text","Comment","originalTag","renderTag","findMappedTag","renderBinding","propsToData","splitter","data2","key","defaultValue","parentProps","slotNodes","node2","isTemplate","slotName","getSlotName","slots2","name","children2","vNodes","child","mergeTextNodes","propsToDataRxModel","propsToDataVBind","propsToDataRxOn","propsToDataRxBind","attribute","find","html","v","native","propName","field","event","evalInContext","e","_key","val","_component","resolveComponent","pascalCase","defineAsyncComponent","resolve","context","result","destr","nodes","mergedNodes","previousNode","loadComponents","c","resolvedComponent","components2","kebabCase"],"mappings":"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","x_google_ignoreList":[0]}