[{"data":1,"prerenderedAt":51},["ShallowReactive",2],{"search-api":3},[4,11,17,25,39],{"id":5,"path":6,"dir":7,"title":8,"description":7,"keywords":9,"body":10},"content:0.index.md","/","","Home",[],"     Senior Laravel/VueJS Engineer    Results-oriented  Software Developer with 20 years of experience across the full software development lifecycle. Proven leadership in both agency and SaaS startup environments. Foster a collaborative and growth-oriented work ethic, with a passion for mentoring and knowledge sharing. Highly organised and analytical, with a demonstrated ability to quickly learn and adapt to new technologies.     Software and product development:   20 years  MySQL:   15 years  Object-Oriented languages:   15 years  Laravel/VueJS:   10 years    (experience with Symfony and Zend, React, TypeScript)  NoSQL:   5 years    (ElasticSearch, MongoDB, Redis)  DevOps:   10 years    (AWS, DigitalOcean and Google Cloud, Docker and Terraform)      My experiences      API design   I have extensive experience in API design, microservices and SPAs.    High Scalability   I managed the development and integration for high-load scalable systems and large-scale, high-traffic environments.    Database performance tuning   Proven expertise with database performance tuning and data retrieval and storage optimization.    AWS products   10+ years working with various AWS products (S3, EC2, EBS, Lambda, RDS and Aurora, SQS, SES).    Continuous integration   FIrm believer of continuous integration approaches, automated testing and deployment, code style checking, automated load testing.    Error/performance monitoring   Implemented error and performance monitoring solutions to maintain system reliability and performance.",{"id":12,"path":13,"dir":7,"title":14,"description":7,"keywords":15,"body":16},"content:1.getting-started.md","/getting-started","Getting started",[],"  Getting started    Articles      Laravel   Laravel related articles.   Read more    Vue   Posts about VueJS.   Read more .    Git   Posts about Git.   Read more .",{"id":18,"path":19,"dir":20,"title":21,"description":22,"keywords":23,"body":24},"content:1.laravel:1.laravel-pipelines.md","/laravel/laravel-pipelines","laravel","Laravel Pipelines","A tale of Laravel Pipelines, form requests and the service container",[],"  Laravel Pipelines  In one of my regular code cleaning sessions I found a piece of code in our controller very similar to this picture:    It looks clean and readable, but the code just went on and on, and made the understanding of the   controller  code much harder than it needs to be.  In this case all I needed to know was that we have an incomin request with parameters, and we have to filter our query based on the different parameters.\nThere is absolutely no need to keep all the implementation details in the controller.   So how to tackle this?  We can extract our various filters to pipes, and send our base query through them:     class   BookingController   extends   Controller\n   {\n       public   function   index  (  ListBookingsRequest   $request)  :   AnonymousResourceCollection\n       {\n           $bookings   =   app  (  Pipeline  ::class  )\n               ->  send  (  Booking  ::  query  ())\n               ->  through  (  pipes  : [\n                   FilterByDateRange  ::class  ,\n                   FilterByRescheduleIdentifier  ::class  ,\n                   FilterByGroupIdentifier  ::class  ,\n                   FilterBySequenceIdentifier  ::class  ,\n                   FilterByBookingFormIdentifier  ::class  ,\n                   FilterByClients  ::class  ,\n                   FilterByStatus  ::class  ,\n                   FilterByTransportRequirement  ::class  ,\n                   FilterByRegion  ::class  ,\n                   FilterByAllocation  ::class  ,\n                   FilterByUuid  ::class  ,\n                   FilterOnlyTrashed  ::class  ,\n                   OrderBookings  ::class  ,\n                   SearchBookings  ::class  ,\n               ])\n               ->  thenReturn  ()\n               ->  paginate  ();\n   \n           return   BookingResource  ::  collection  ($bookings);\n       }\n   }\n  The problem arises when we need to pass multiple arguments to our filter classes, in our cases we need to pass the   request  in order to extract the filter parameters:     class   FilterByDateRange\n   {\n       public   function   __invoke  (  Builder   $query,   Closure   $next)  :   Builder\n       {\n           return   $next($query)\n               ->  when  (\n                   value  :   $this  ->  request  ->  filled  (  'date'  ),\n                   callback  :   function   (  Builder   $q) {\n                       $date   =   Carbon  ::  parse  (  $this  ->  request  ->  validated  (  'date'  ),   organisation_timezone  ());\n                       return   $q  ->  whereBetween  (\n                           column  :   'date'  ,\n                           values  : [\n                               $date  ->  clone  ()  ->  startOfDay  ()  ->  utc  ()  ->  toDateTimeString  (),\n                               $date  ->  clone  ()  ->  endOfDay  ()  ->  utc  ()  ->  toDateTimeString  (),\n                           ]\n                       );\n                   }\n               );\n       }\n   }\n  One option is to use DTOs, constructed from the base query, and the various request fields we need.  The other option is to rely on Laravel's service container to inject the request instance to our filters.\nBy simply typing a   FormRequest $request  in our consturctor, we instruct Laravel to inject the current form request:     class   FilterByDateRange\n   {\n       public   function   __construct  (  protected   FormRequest   $request)\n       {\n       }\n   \n       //...\n   }\n  We need to use   FormRequest  as a type, so we have access to the   validated  method.\nHere's our redacted form request class:     class   ListBookingsRequest   extends   FormRequest\n   {\n       public   function   authorize  ()  :   bool\n       {\n           return   $this  ->  user  ()  ->  can  (  'viewAny'  ,   Booking  ::class  );\n       }\n   \n       public   function   rules  ()  :   array\n       {\n           return   [\n               // ...\n               'clients'   =>   [  'sometimes'  ,   'array'  ],\n               'clients.*'   =>   [  'sometimes'  ,   Rule  ::  exists  ((  new   Client  ())  ->  getTable  (),   'uuid'  )],\n               // ...\n               'uuids.*'   =>   [  'sometimes'  ,   Rule  ::  exists  ((  new   Booking  ())  ->  getTable  (),   'uuid'  )],\n               'date'   =>   [  'bail'  ,   'nullable'  ,   'string'  ,   'max:255'  ,   'date'  ],\n               // ...\n               'status_filter'   =>   [  'nullable'  ,   'array'  ],\n               'status_filter.*'   =>   [  'nullable'  ,   'string'  ,   'max:255'  ,   Rule  ::  in  (  BookingStatus  ::  values  ())],\n               // ...\n               'transport_requirements'   =>   [  'sometimes'  ,   'array'  ],\n               'transport_requirements.*.code'   =>   [  'required'  ,   Rule  ::  exists  ((  new   TransportRequirement  ())  ->  getTable  (),   'code'  )],\n           ];\n       }\n   }\n  There is only one problem with this approach,which we learnt the hard way.\nLaravel will inject a   new  instance of the request for every filter class instance.   Why it is a problem?  For two reasons in our form request: our   authorize  method, and our   exists  and   in  rules.\nBoth the   authorize  method and the various rules will execute database queries for each instance of the request.   In our case 5 queries per request instance used in 14 different filters:   70 queries .  While this was a fairly obscure bug to track down, the fix is relatively easy:   Do not relay on the service container, but   pass the request manually  to the filters:     class   BookingController   extends   Controller\n   {\n       public   function   index  (  ListBookingsRequest   $request)  :   AnonymousResourceCollection\n       {\n           $bookings   =   app  (  Pipeline  ::class  )\n               ->  send  (  Booking  ::  query  ())\n               ->  through  (  pipes  : [\n                   new   FilterByRescheduleIdentifier  ($request),\n                   new   FilterByGroupIdentifier  ($request),\n                   new   FilterBySequenceIdentifier  ($request),\n                   new   FilterByBookingFormIdentifier  ($request),\n                   new   FilterByClients  ($request),\n                   new   FilterByDate  ($request),\n                   new   FilterByDateRange  ($request),\n                   new   FilterByStatus  ($request),\n                   new   FilterByTransportRequirement  ($request),\n                   new   FilterByRegion  ($request),\n                   new   OrderBookings  ($request),\n                   new   SearchBookings  ($request),\n                   new   FilterByAllocation  ($request),\n                   new   FilterByUuid  ($request),\n                   new   FilterOnlyTrashed  ($request),\n               ])\n               ->  thenReturn  ()\n               ->  paginate  ();\n   \n           return   BookingResource  ::  collection  ($Booking);\n       }\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":26,"path":27,"dir":28,"title":29,"description":30,"keywords":31,"body":38},"content:2.vue:1.vue-props.md","/vue/vue-props","vue","Vue Props","How to pass writeable properties to child components",[32,33,34,35,36,37],"Parent component","Naive implementation","Reactive variable","Writeable computed property","VueUse composable","Watchers","  Vue Props  It is a farily common scenario in any system that the frontend receives some initial data from a backend, and then modifies and sends it back.  If the UI is more complex, and consist of nested elements, usually the parent component gets the data, and passes down to its children as properties.\nOnce the child modifies it, it has to push back the changes to the parent component responsible for the API communication.\nVue actually doesn't make it simple to achive this, with the readonly properties.  Let me summarise the requirements:   The child component must be able to recieve an initial value  It also must be able to reflect any changes to this value later  And finally must be able to change this data, and communicate this changes to its parent  Parent component  Here is a simple example of a parent components, having a reactive   counter  property, passed down to it's child:     \u003C  template  >\n       \u003C  Panel  >\n           \u003C  template   #  header  >\n               \u003C  header   class  =  \"p-5 m-5\"  >\n                   \u003C  div   class  =  \"wrapper\"  >\u003C/  div  >\n               \u003C/  header  >\n           \u003C/  template  >\n   \n           \u003C  main   class  =  \"p-5 flex flex-row gap-5\"  >\n               \u003C  Card   class  =  \"basis-1/2\"  >\n                   \u003C  template   #  title  >Counter: {{ counter }}\u003C/  template  >\n                   \u003C  template   #  content  >\n                       \u003C  CounterComponent   :  counter  =  \"  counter  \"   @  update  :  counter  =  \"  (  event  :   number  )   =>   (counter   =   event)  \"   />\n                   \u003C/  template  >\n                   \u003C  template   #  footer  >\n                       \u003C  Button   @  click  =  \"  counter  ++  \"  >Increment\u003C/  Button  >\n                       \u003C  Button   @  click  =  \"  counter  --  \"  >Decrement\u003C/  Button  >\n                   \u003C/  template  >\n               \u003C/  Card  >\n           \u003C/  main  >\n       \u003C/  Panel  >\n   \u003C/  template  >\n   \n   \u003C  script   setup   lang  =  \"ts\"  >\n   import   { ref,   type   Ref }   from   'vue'\n   import   Card   from   'primevue/card'\n   import   Button   from   'primevue/Button'\n   \n   const   counter  :   Ref  \u003C  number  >   =   ref  \u003C  number  >(  10  )\n   \u003C/  script  >\n  Naive implementation  The naive implementation of the children is to also have a property called   counter :     \u003C  template  >\n     \u003C  Card  >\n       \u003C  template   #  content  >\n         \u003C  InputNumber   v-model  =  \"  props.counter  \"   />\n       \u003C/  template  >\n       \u003C  template   #  footer  >\n         \u003C  Button   @  click  =  \"  props.counter  ++  \"  >Increment\u003C/  Button  >\n         \u003C  Button   @  click  =  \"  props.counter  --  \"  >Decrement\u003C/  Button  >\n       \u003C/  template  >\n     \u003C/  Card  >\n   \u003C/  template  >\n   \n   \u003C  script   setup   lang  =  \"ts\"  >\n   import   InputNumber   from   'primevue/inputnumber'\n   import   Card   from   'primevue/card'\n   import   Button   from   'primevue/Button'\n   import   { computed }   from   'vue'\n   \n   const   props   =   defineProps  ({\n     counter: {\n       type: Number,\n       required:   true\n     }\n   });\n   \u003C/  script  >\n  There is one massive problem with this:   Properties are   readonly  in Vue.  Reactive variable  We can change our implementation that the children also have a reactive   counter  variable, and maybe copy out the initial value of the property:     \u003C  template  >\n     \u003C  Card  >\n       \u003C  template   #  content  >\n         \u003C  InputNumber   v-model  =  \"  counter  \"   />\n       \u003C/  template  >\n       \u003C  template   #  footer  >\n         \u003C  Button   @  click  =  \"  counter  ++  \"  >Increment\u003C/  Button  >\n         \u003C  Button   @  click  =  \"  counter  --  \"  >Decrement\u003C/  Button  >\n       \u003C/  template  >\n     \u003C/  Card  >\n   \u003C/  template  >\n   \n   \u003C  script   setup   lang  =  \"ts\"  >\n   import   InputNumber   from   'primevue/inputnumber'\n   import   Card   from   'primevue/card'\n   import   Button   from   'primevue/Button'\n   import   { ref }   from   'vue'\n   \n   const   props   =   defineProps  ({\n     counter: {\n       type: Number,\n       required:   true\n     }\n   });\n   \n   const   counter   =   ref  (props.counter);\n   \u003C/  script  >\n  While this solution eliminates the problem with not being able to update the counter from within the child component, and also receives the initial value from the parent component, it won't react if it gets updated in the parent:   Making a field of the props reactive   disconnects  it from the parent data.  Writeable computed property  A common solution to this is something called writeable computed property, which involves a computed variable, where the getter part returns the property directly, while the setter part emits an event to the parent component, and delegates the responsibility of updating the data.     \u003C  template  >...\u003C/  template  >\n   \n   \u003C  script   setup   lang  =  \"ts\"  >\n   import   InputNumber   from   'primevue/inputnumber'\n   import   Card   from   'primevue/card'\n   import   Button   from   'primevue/Button'\n   import   { ref }   from   'vue'\n   \n   const   props   =   defineProps  ({\n     counter: {\n       type: Number,\n       required:   true\n     }\n   });\n   \n   const   emit   =   defineEmits  ([  'update:counter'  ]);\n   \n   const   counter   =   computed  ({\n     get  () {\n       return   props.counter\n     },\n     set  (  value  ) {\n       emit  (  'update:counter'  , value)\n     }\n   });\n   \u003C/  script  >\n  This solves all our initial requirements, it can receive initial data from the parent, can update the value, and this update is emitted to the parent.  VueUse composable  This is a common solution, as a matter of fact the   VueUse library  has a composable called   useVModel  to simplify this syntax:     \u003C  template  >...\u003C/  template  >\n   \n   \u003C  script   setup   lang  =  \"ts\"  >\n   import   InputNumber   from   'primevue/inputnumber'\n   import   Card   from   'primevue/card'\n   import   Button   from   'primevue/button'\n   import   { useVModel }   from   '@vueuse/core'\n   \n   const   props   =   defineProps  ({\n       counter: {\n           type: Number,\n           required:   true\n       }\n   });\n   \n   const   emit   =   defineEmits  ([  'update:counter'  ]);\n   const   counter   =   useVModel  (props,   'counter'  , emit);\n   \u003C/  script  >\n  There is only one big issue with this. This component can not work on it's own, it always relies on it's parent to update the data.   If the update event is not handled in the parent, the children   can't update its own internal state  on its own.  This can be easy to overlook, and might be hard to debug.   So how to tackle this?  Watchers  In general I'm not a huge fan of watchers, but in this case this one seems to be the final solution:   The children can get an initial data from its parent  If the data is changed in the parent, it will be reflected in the children  The children can modify the data internally  This update   can  be emitted to the parent - but it is not a requirement for the child component to work     \u003C  template  >\n       \u003C  Card  >\n           \u003C  template   #  title  >Child counter: {{ counter }}\u003C/  template  >\n           \u003C  template   #  content  >\n               \u003C  InputNumber   v-model  =  \"  counter  \"   />\n           \u003C/  template  >\n           \u003C  template   #  footer  >\n               \u003C  Button   @  click  =  \"  counter  ++  \"  >Increment\u003C/  Button  >\n               \u003C  Button   @  click  =  \"  counter  --  \"  >Decrement\u003C/  Button  >\n           \u003C/  template  >\n       \u003C/  Card  >\n   \u003C/  template  >\n   \n   \u003C  script   setup   lang  =  \"ts\"  >\n   import   InputNumber   from   'primevue/inputnumber'\n   import   Card   from   'primevue/card'\n   import   Button   from   'primevue/button'\n   import   { ref, watch,   type   Ref }   from   'vue'\n   \n   const   props   =   defineProps  ({\n       counter: {\n           type: Number,\n           required:   true\n       }\n   });\n   \n   const   emit   =   defineEmits  ([  'update:counter'  ]);\n   const   counter  :   Ref  \u003C  number  >   =   ref  (props.counter);\n   \n   watch  (()   =>   props.counter, (  value  :   number  )   =>   counter.value   =   value);\n   watch  (()   =>   counter.value, (  value  :   number  )   =>   emit  (  'update:counter'  , value));\n   \n   \u003C/  script  >\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":40,"path":41,"dir":42,"title":43,"description":44,"keywords":45,"body":50},"content:3.git:1.git-worktree.md","/git/git-worktree","git","Git Worktrees","How to work on multiple git branches simultaneously",[46,47,48,49],"Listing worktrees","Creating a new worktree","Deleting worktrees","Pros and cons","  Git Worktrees  In the recent weeks I am working on a big feature of our system, with a lot of changes, and a decent development time. But since life doesn't stop, I still have to respond to maintenance requests and bug fixes, which means I frequently have to switch between branches. The initial method I learnt many years ago was to commit or stash my changes, checkout the other branch, do the fix, commit, push, and then come back to the original code.  Needless to say, this is a lot of switching, stashing, committing - a lot of room for errors and making a mess in the repository.  Couple of weeks ago I came across an article, which introduced a very interesting concept to me, Git Worktrees.  This feature basically allows me to checkout multiple branches of the same repository, but without the overhead of checking out the whole project again. The worktree points to a folder in your file system, and references a branch, but working from the same clone.  Listing worktrees  To see all available worktrees, you can use the   git worktree list  command:     git   worktree   list\n   /Users/balazssebesteny/Sites/balazs.sebesteny.com    53b470d   [main]\n  Creating a new worktree  Let's assume you are working on a feature, but an urgent bugfix request came in. To create a worktree for an existing branch, you can use the following :     git   worktree   add   ../balazs.sebesteny.com-bugfix-01   bugfix-01\n   Preparing   worktree   (new   branch   'bugfix-01'  )\n   branch   'bugfix-01'   set   up   to   track   'origin/bugfix-01'.\n   HEAD   is   now   at   53b470d   SEO\n  If we take a look into the new folder created, we can see that there is no   .git  folder, but only a single   .git  file:     ls   -la   ./\n   total   1496\n   drwxr-xr-x@   18   balazssebesteny    staff       576   25   Jul   13:40   .\n   drwxr-xr-x    40   balazssebesteny    staff      1280   25   Jul   13:40   ..\n   -rw-r--r--@    1   balazssebesteny    staff       104   25   Jul   13:40   .git\n   -rwxr-xr-x@    1   balazssebesteny    staff        88   25   Jul   13:40   .gitignore\n   -rw-r--r--@    1   balazssebesteny    staff        53   25   Jul   13:40   .npmrc\n   -rwxr-xr-x@    1   balazssebesteny    staff       952   25   Jul   13:40   README.md\n   ...\n  This contains the reference to the original clone's   .git  folder, and ensures that our usual Git commands are working:     cat   ..git\n   gitdir:   /Users/balazssebesteny/Sites/balazs.sebesteny.com/.git/worktrees/balazs.sebesteny.com-bugfix-01\n  And we can see our   bugfix-01  branch checked out:     git   status\n   On   branch   bugfix-01\n   Your   branch   is   up   to   date   with   'origin/bugfix-01'.\n   \n   nothing   to   commit,   working   tree   clean\n  At the end of the day we can implement our fix in this folder, test it, commit and push it, and done.  Creating a new worktree along with a new branch  If we didn't create out bugfix branch in our repository provider UI, we can always do it like this:     git   worktree   add   ../balazs.sebesteny.com-bugfix-02   origin/main   -b   bugfix-02\n   Preparing   worktree   (new   branch   'bugfix-02'  )\n   branch   'bugfix-02'   set   up   to   track   'origin/main'.\n   HEAD   is   now   at   53b470d   SEO\n  Deleting worktrees  Once we finished our work in the extra worktrees, we can simply remove them:     git   worktree   list\n   /Users/balazssebesteny/Sites/balazs.sebesteny.com              53b470d   [main]\n   /Users/balazssebesteny/Sites/balazs.sebesteny.com-bugfix-01    53b470d   [bugfix-01]\n   /Users/balazssebesteny/Sites/balazs.sebesteny.com-bugfix-02    53b470d   [bugfix-02]\n   \n   git   worktree   remove   ../balazs.sebesteny.com-bugfix-01\n   git   worktree   remove   ../balazs.sebesteny.com-bugfix-02\n   \n   git   worktree   list\n   /Users/balazssebesteny/Sites/balazs.sebesteny.com    53b470d   [main]\n  Pros and cons  The big advantage is that we don't have to clone the repository multiple times, the   .git  folder is shared, our worktrees will use the same git config, if you fetch in any of the worktrees it will fetch in all, etc.  One arguable disadvantage is that you will end up multiple top level directories, which can be inconvenient from an organising point of view.  And one more sidenote, one branch can only have one worktree.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",1721872845184]