[{"data":1,"prerenderedAt":39},["ShallowReactive",2],{"search-api":3},[4,11,17,25],{"id":5,"path":6,"dir":7,"title":8,"description":7,"keywords":9,"body":10},"content:0.index.md","/","","Home",[],"     Senior Software Engineer    Results-oriented  Software Developer with 20 years of experience across the full software development lifecycle. Proven leadership in both agency and SaaS startup environments. Foster a collaborative and growth-oriented work ethic, with a passion for mentoring and knowledge sharing. Highly organised and analytical, with a demonstrated ability to quickly learn and adapt to new technologies.     Software and product development:   20 years  MySQL:   15 years  Object-Oriented languages:   15 years  Laravel/VueJS:   10 years    (experience with Symfony and Zend, React, TypeScript)  NoSQL:   5 years    (ElasticSearch, MongoDB, Redis)  DevOps:   10 years    (AWS, DigitalOcean and Google Cloud, Docker and Terraform)      My experiences      API design   I have extensive experience in API design, microservices and SPAs.    High Scalability   I managed the development and integration for high-load scalable systems and large-scale, high-traffic environments.    Database performance tuning   Proven expertise with database performance tuning and data retrieval and storage optimization.    AWS products   10+ years working with various AWS products (S3, EC2, EBS, Lambda, RDS and Aurora, SQS, SES).    Continuous integration   FIrm believer of continuous integration approaches, automated testing and deployment, code style checking, automated load testing.    Error/performance monitoring   Implemented error and performance monitoring solutions to maintain system reliability and performance.",{"id":12,"path":13,"dir":7,"title":14,"description":7,"keywords":15,"body":16},"content:1.getting-started.md","/getting-started","Getting started",[],"  Getting started    Articles      Laravel   Laravel related articles.   Read more    Vue   Posts about VueJS.   Read more .",{"id":18,"path":19,"dir":20,"title":21,"description":22,"keywords":23,"body":24},"content:1.laravel:1.laravel-pipelines.md","/laravel/laravel-pipelines","laravel","Laravel Pipelines","A tale of Laravel Pipelines, form requests and the service container",[],"  Laravel Pipelines  In one of my regular code cleaning sessions I found a piece of code in our controller very similar to this picture:    It looks clean and readable, but the code just went on and on, and made the understanding of the   controller  code much harder than it needs to be.  In this case all I needed to know was that we have an incomin request with parameters, and we have to filter our query based on the different parameters.\nThere is absolutely no need to keep all the implementation details in the controller.   So how to tackle this?  We can extract our various filters to pipes, and send our base query through them:     class   BookingController   extends   Controller\n   {\n       public   function   index  (  ListBookingsRequest   $request)  :   AnonymousResourceCollection\n       {\n           $bookings   =   app  (  Pipeline  ::class  )\n               ->  send  (  Booking  ::  query  ())\n               ->  through  (  pipes  : [\n                   FilterByDateRange  ::class  ,\n                   FilterByRescheduleIdentifier  ::class  ,\n                   FilterByGroupIdentifier  ::class  ,\n                   FilterBySequenceIdentifier  ::class  ,\n                   FilterByBookingFormIdentifier  ::class  ,\n                   FilterByClients  ::class  ,\n                   FilterByStatus  ::class  ,\n                   FilterByTransportRequirement  ::class  ,\n                   FilterByRegion  ::class  ,\n                   FilterByAllocation  ::class  ,\n                   FilterByUuid  ::class  ,\n                   FilterOnlyTrashed  ::class  ,\n                   OrderBookings  ::class  ,\n                   SearchBookings  ::class  ,\n               ])\n               ->  thenReturn  ()\n               ->  paginate  ();\n   \n           return   BookingResource  ::  collection  ($bookings);\n       }\n   }\n  The problem arises when we need to pass multiple arguments to our filter classes, in our cases we need to pass the   request  in order to extract the filter parameters:     class   FilterByDateRange\n   {\n       public   function   __invoke  (  Builder   $query,   Closure   $next)  :   Builder\n       {\n           return   $next($query)\n               ->  when  (\n                   value  :   $this  ->  request  ->  filled  (  'date'  ),\n                   callback  :   function   (  Builder   $q) {\n                       $date   =   Carbon  ::  parse  (  $this  ->  request  ->  validated  (  'date'  ),   organisation_timezone  ());\n                       return   $q  ->  whereBetween  (\n                           column  :   'date'  ,\n                           values  : [\n                               $date  ->  clone  ()  ->  startOfDay  ()  ->  utc  ()  ->  toDateTimeString  (),\n                               $date  ->  clone  ()  ->  endOfDay  ()  ->  utc  ()  ->  toDateTimeString  (),\n                           ]\n                       );\n                   }\n               );\n       }\n   }\n  One option is to use DTOs, constructed from the base query, and the various request fields we need.  The other option is to rely on Laravel's service container to inject the request instance to our filters.\nBy simply typing a   FormRequest $request  in our consturctor, we instruct Laravel to inject the current form request:     class   FilterByDateRange\n   {\n       public   function   __construct  (  protected   FormRequest   $request)\n       {\n       }\n   \n       //...\n   }\n  We need to use   FormRequest  as a type, so we have access to the   validated  method.\nHere's our redacted form request class:     class   ListBookingsRequest   extends   FormRequest\n   {\n       public   function   authorize  ()  :   bool\n       {\n           return   $this  ->  user  ()  ->  can  (  'viewAny'  ,   Booking  ::class  );\n       }\n   \n       public   function   rules  ()  :   array\n       {\n           return   [\n               // ...\n               'clients'   =>   [  'sometimes'  ,   'array'  ],\n               'clients.*'   =>   [  'sometimes'  ,   Rule  ::  exists  ((  new   Client  ())  ->  getTable  (),   'uuid'  )],\n               // ...\n               'uuids.*'   =>   [  'sometimes'  ,   Rule  ::  exists  ((  new   Booking  ())  ->  getTable  (),   'uuid'  )],\n               'date'   =>   [  'bail'  ,   'nullable'  ,   'string'  ,   'max:255'  ,   'date'  ],\n               // ...\n               'status_filter'   =>   [  'nullable'  ,   'array'  ],\n               'status_filter.*'   =>   [  'nullable'  ,   'string'  ,   'max:255'  ,   Rule  ::  in  (  BookingStatus  ::  values  ())],\n               // ...\n               'transport_requirements'   =>   [  'sometimes'  ,   'array'  ],\n               'transport_requirements.*.code'   =>   [  'required'  ,   Rule  ::  exists  ((  new   TransportRequirement  ())  ->  getTable  (),   'code'  )],\n           ];\n       }\n   }\n  There is only one problem with this approach,which we learnt the hard way.\nLaravel will inject a   new  instance of the request for every filter class instance.   Why it is a problem?  For two reasons in our form request: our   authorize  method, and our   exists  and   in  rules.\nBoth the   authorize  method and the various rules will execute database queries for each instance of the request.   In our case 5 queries per request instance used in 14 different filters:   70 queries .  While this was a fairly obscure bug to track down, the fix is relatively easy:   Do not relay on the service container, but   pass the request manually  to the filters:     class   BookingController   extends   Controller\n   {\n       public   function   index  (  ListBookingsRequest   $request)  :   AnonymousResourceCollection\n       {\n           $bookings   =   app  (  Pipeline  ::class  )\n               ->  send  (  Booking  ::  query  ())\n               ->  through  (  pipes  : [\n                   new   FilterByRescheduleIdentifier  ($request),\n                   new   FilterByGroupIdentifier  ($request),\n                   new   FilterBySequenceIdentifier  ($request),\n                   new   FilterByBookingFormIdentifier  ($request),\n                   new   FilterByClients  ($request),\n                   new   FilterByDate  ($request),\n                   new   FilterByDateRange  ($request),\n                   new   FilterByStatus  ($request),\n                   new   FilterByTransportRequirement  ($request),\n                   new   FilterByRegion  ($request),\n                   new   OrderBookings  ($request),\n                   new   SearchBookings  ($request),\n                   new   FilterByAllocation  ($request),\n                   new   FilterByUuid  ($request),\n                   new   FilterOnlyTrashed  ($request),\n               ])\n               ->  thenReturn  ()\n               ->  paginate  ();\n   \n           return   BookingResource  ::  collection  ($Booking);\n       }\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"id":26,"path":27,"dir":28,"title":29,"description":30,"keywords":31,"body":38},"content:2.vue:1.vue-props.md","/vue/vue-props","vue","Vue Props","How to pass writeable properties to child components",[32,33,34,35,36,37],"Parent component","Naive implementation","Reactive variable","Writeable computed property","VueUse composable","Watchers","  Vue Props  It is a farily common scenario in any system that the frontend receives some initial data from a backend, and then modifies and sends it back.  If the UI is more complex, and consist of nested elements, usually the parent component gets the data, and passes down to its children as properties.\nOnce the child modifies it, it has to push back the changes to the parent component responsible for the API communication.\nVue actually doesn't make it simple to achive this, with the readonly properties.  Let me summarise the requirements:   The child component must be able to recieve an initial value  It also must be able to reflect any changes to this value later  And finally must be able to change this data, and communicate this changes to its parent  Parent component  Here is a simple example of a parent components, having a reactive   counter  property, passed down to it's child:     \u003C  template  >\n       \u003C  Panel  >\n           \u003C  template   #  header  >\n               \u003C  header   class  =  \"p-5 m-5\"  >\n                   \u003C  div   class  =  \"wrapper\"  >\u003C/  div  >\n               \u003C/  header  >\n           \u003C/  template  >\n   \n           \u003C  main   class  =  \"p-5 flex flex-row gap-5\"  >\n               \u003C  Card   class  =  \"basis-1/2\"  >\n                   \u003C  template   #  title  >Counter: {{ counter }}\u003C/  template  >\n                   \u003C  template   #  content  >\n                       \u003C  CounterComponent   :  counter  =  \"  counter  \"   @  update  :  counter  =  \"  (  event  :   number  )   =>   (counter   =   event)  \"   />\n                   \u003C/  template  >\n                   \u003C  template   #  footer  >\n                       \u003C  Button   @  click  =  \"  counter  ++  \"  >Increment\u003C/  Button  >\n                       \u003C  Button   @  click  =  \"  counter  --  \"  >Decrement\u003C/  Button  >\n                   \u003C/  template  >\n               \u003C/  Card  >\n           \u003C/  main  >\n       \u003C/  Panel  >\n   \u003C/  template  >\n   \n   \u003C  script   setup   lang  =  \"ts\"  >\n   import   { ref,   type   Ref }   from   'vue'\n   import   Card   from   'primevue/card'\n   import   Button   from   'primevue/Button'\n   \n   const   counter  :   Ref  \u003C  number  >   =   ref  \u003C  number  >(  10  )\n   \u003C/  script  >\n  Naive implementation  The naive implementation of the children is to also have a property called   counter :     \u003C  template  >\n     \u003C  Card  >\n       \u003C  template   #  content  >\n         \u003C  InputNumber   v-model  =  \"  props.counter  \"   />\n       \u003C/  template  >\n       \u003C  template   #  footer  >\n         \u003C  Button   @  click  =  \"  props.counter  ++  \"  >Increment\u003C/  Button  >\n         \u003C  Button   @  click  =  \"  props.counter  --  \"  >Decrement\u003C/  Button  >\n       \u003C/  template  >\n     \u003C/  Card  >\n   \u003C/  template  >\n   \n   \u003C  script   setup   lang  =  \"ts\"  >\n   import   InputNumber   from   'primevue/inputnumber'\n   import   Card   from   'primevue/card'\n   import   Button   from   'primevue/Button'\n   import   { computed }   from   'vue'\n   \n   const   props   =   defineProps  ({\n     counter: {\n       type: Number,\n       required:   true\n     }\n   });\n   \u003C/  script  >\n  There is one massive problem with this:   Properties are   readonly  in Vue.  Reactive variable  We can change our implementation that the children also have a reactive   counter  variable, and maybe copy out the initial value of the property:     \u003C  template  >\n     \u003C  Card  >\n       \u003C  template   #  content  >\n         \u003C  InputNumber   v-model  =  \"  counter  \"   />\n       \u003C/  template  >\n       \u003C  template   #  footer  >\n         \u003C  Button   @  click  =  \"  counter  ++  \"  >Increment\u003C/  Button  >\n         \u003C  Button   @  click  =  \"  counter  --  \"  >Decrement\u003C/  Button  >\n       \u003C/  template  >\n     \u003C/  Card  >\n   \u003C/  template  >\n   \n   \u003C  script   setup   lang  =  \"ts\"  >\n   import   InputNumber   from   'primevue/inputnumber'\n   import   Card   from   'primevue/card'\n   import   Button   from   'primevue/Button'\n   import   { ref }   from   'vue'\n   \n   const   props   =   defineProps  ({\n     counter: {\n       type: Number,\n       required:   true\n     }\n   });\n   \n   const   counter   =   ref  (props.counter);\n   \u003C/  script  >\n  While this solution eliminates the problem with not being able to update the counter from within the child component, and also receives the initial value from the parent component, it won't react if it gets updated in the parent:   Making a field of the props reactive   disconnects  it from the parent data.  Writeable computed property  A common solution to this is something called writeable computed property, which involves a computed variable, where the getter part returns the property directly, while the setter part emits an event to the parent component, and delegates the responsibility of updating the data.     \u003C  template  >...\u003C/  template  >\n   \n   \u003C  script   setup   lang  =  \"ts\"  >\n   import   InputNumber   from   'primevue/inputnumber'\n   import   Card   from   'primevue/card'\n   import   Button   from   'primevue/Button'\n   import   { ref }   from   'vue'\n   \n   const   props   =   defineProps  ({\n     counter: {\n       type: Number,\n       required:   true\n     }\n   });\n   \n   const   emit   =   defineEmits  ([  'update:counter'  ]);\n   \n   const   counter   =   computed  ({\n     get  () {\n       return   props.counter\n     },\n     set  (  value  ) {\n       emit  (  'update:counter'  , value)\n     }\n   });\n   \u003C/  script  >\n  This solves all our initial requirements, it can receive initial data from the parent, can update the value, and this update is emitted to the parent.  VueUse composable  This is a common solution, as a matter of fact the   VueUse library  has a composable called   useVModel  to simplify this syntax:     \u003C  template  >...\u003C/  template  >\n   \n   \u003C  script   setup   lang  =  \"ts\"  >\n   import   InputNumber   from   'primevue/inputnumber'\n   import   Card   from   'primevue/card'\n   import   Button   from   'primevue/button'\n   import   { useVModel }   from   '@vueuse/core'\n   \n   const   props   =   defineProps  ({\n       counter: {\n           type: Number,\n           required:   true\n       }\n   });\n   \n   const   emit   =   defineEmits  ([  'update:counter'  ]);\n   const   counter   =   useVModel  (props,   'counter'  , emit);\n   \u003C/  script  >\n  There is only one big issue with this. This component can not work on it's own, it always relies on it's parent to update the data.   If the update event is not handled in the parent, the children   can't update its own internal state  on its own.  This can be easy to overlook, and might be hard to debug.   So how to tackle this?  Watchers  In general I'm not a huge fan of watchers, but in this case this one seems to be the final solution:   The children can get an initial data from its parent  If the data is changed in the parent, it will be reflected in the children  The children can modify the data internally  This update   can  be emitted to the parent - but it is not a requirement for the child component to work     \u003C  template  >\n       \u003C  Card  >\n           \u003C  template   #  title  >Child counter: {{ counter }}\u003C/  template  >\n           \u003C  template   #  content  >\n               \u003C  InputNumber   v-model  =  \"  counter  \"   />\n           \u003C/  template  >\n           \u003C  template   #  footer  >\n               \u003C  Button   @  click  =  \"  counter  ++  \"  >Increment\u003C/  Button  >\n               \u003C  Button   @  click  =  \"  counter  --  \"  >Decrement\u003C/  Button  >\n           \u003C/  template  >\n       \u003C/  Card  >\n   \u003C/  template  >\n   \n   \u003C  script   setup   lang  =  \"ts\"  >\n   import   InputNumber   from   'primevue/inputnumber'\n   import   Card   from   'primevue/card'\n   import   Button   from   'primevue/button'\n   import   { ref, watch,   type   Ref }   from   'vue'\n   \n   const   props   =   defineProps  ({\n       counter: {\n           type: Number,\n           required:   true\n       }\n   });\n   \n   const   emit   =   defineEmits  ([  'update:counter'  ]);\n   const   counter  :   Ref  \u003C  number  >   =   ref  (props.counter);\n   \n   watch  (()   =>   props.counter, (  value  :   number  )   =>   counter.value   =   value);\n   watch  (()   =>   counter.value, (  value  :   number  )   =>   emit  (  'update:counter'  , value));\n   \n   \u003C/  script  >\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",1721507090927]